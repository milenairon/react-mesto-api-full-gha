[![Статус тестов](../../actions/workflows/tests.yml/badge.svg)](../../actions/workflows/tests.yml)

# Учебный проект: "Место"

---

<div align="center">
  <a href="https://milenairon.nomoredomainsmonster.ru">
    <img width="600" alt="Основной экран приложения" src="https://sun9-14.userapi.com/impg/oZZOV3XagogeCpkV2eDvehy31E2Aq43TApzlVA/73HCl_2WRRY.jpg?size=992x637&quality=95&sign=675541fca4371d84dca18169325a05fd&type=album">
  </a>
</div>

---
## Оглавление

1. Описание
2. Ссылка на GitHub Pages
3. Функциональность
4. Технологии, используемые в проекте. Frontend
5. Технологии, используемые в проекте. Backend

---

## 1. Описание

Репозиторий для приложения проекта `Mesto`, включающий фронтенд и бэкенд части приложения со следующими возможностями: авторизации и регистрации пользователей, операции с карточками и пользователями. 

Фронтенд-часть проекта написана на реакте, так как код? написанный на данной библиотеке js, имеет следующие достоинства:

- экономится время на написании кода;
- контент загружается быстрее (особенно при плохом соединении и на медленных устройствах);
- улучшает ранжирование в поисковиках (поисковые боты будут видеть полностью отрендеренную страницу).

Бэкэнд часть проекта написана на JavaScript.


## 2. Ссылки на проект

IP 158.160.98.10

Frontend https://milenairon.nomoredomainsmonster.ru

Backend https://api.milenairon.nomoredomainsmonster.ru

Адрес репозитория: https://github.com/milenairon/react-mesto-api-full-gha


## 3. Функциональность

Данный сайт обладает следующими критериями функциональности:

- дизайн;
- контент;
- структура;
- доступные функции;

Под функциями понимаются возможности:

- возможность зарегистрироваться, а далее авторизироваться на сайте;
- зайти на сайт, минуя страницу "вход в систему", если пользователь уже заходил;
- просмотра тектового материала без перехода на сторонние сайты;
- просмотра тектового материала без перехода на сторонние сайты;
- возможность изменения имени и места работы в сплывающем pop up;
- коректное внесение имени и "о себе", названия картинки и ссылки на нее в сплывающих pop up;
- возможность сохранения свои данных после ввода;
- возможность закрытия страницы без сохранения своих данных разными способами, описанными ранее.
- возможность добавления карточки в сплывающем pop up;
- возможность удаления карточки, а также постановки лайка карточке;
- возможность открытия картинки в большем масштабе в сплывающем pop up;

---

## 4. Технологии, используемые в проекте. Frontend

В проекте были применены следующие технологии:

- подключение к серверу;
- сборка проекта. Webpack;
- регистрация пользователя;
- авторизация пользователя;
- вход пользователя, сохраненного в локальном хранилище;
- применение классов;
- валидация форм;
- открытие и закрытие pop up по клику мышкой, нажатию на кнопку "Esc", клику на фон;
- редактиование и сохранение данных;
- Добавление карточки в сплывающем pop up;
- Удаление карточки;
- Постановка лайка карточке;
- Открытие картинки в большем масштабе в сплывающем pop up;
- адаптивность сайта;
- "резиновость" сайта;
- флекc-элементы;
- грид-элементы;
- подключение шрифтов;
- "отзывчивость" интерактивных элементов;
- файловая структура проекта по правилам Nested БЭМ;

### 4.1 Подключение к серверу

Данная технология реазилуется за счет следующих шагов:
4.1.1. Загрузка информации о пользователе с сервера
4.1.2. Загрузка карточек с сервера
4.1.3. Редактирование профиля
4.1.4. Добавление новой карточки
4.1.5. Отображение количества лайков карточки
4.1.6. Попап удаления карточки
4.1.7. Удаление карточки
4.1.8. Постановка и снятие лайка
4.1.9. Обновление аватара пользователя
4.1.10. Улучшенный UX всех форм

Данные технологии осуществлялись засчет получения/загрузки на сервер информации путем использования запроса с использованием индивидуального токена и названия когорты в классе Api. Ниже приведен пример загрузки информации о пользователе с сервера

```
Api.js:

getUserInfo() {
    return (
      fetch(`https://nomoreparties.co/v1/cohortId/users/me `, {
      method: "GET",
      headers: this._headers,
    })
        .then((res) => {
          if (res.ok) {
            return res.json();
          }
          //если запрос ушел, но пришел ответ с ошибкой
          return new Error("Что-то пошло не так"); //СОЗДАТЬ КЛАСС
        })
        //если запрос не ушел
        .catch((error) => {
          console.log(error);
        })
    );
  }
```

```
index.js:

api
.getUserInfo() //Получить мои данные
.then((user) => {
  userInfoElement.editProfile(user);
})

```

Все основные функции и изменения переменных реализуются в документе App, его дочерние компоненты содержат лишь функции, связанные с отправкой формы, и функции, пробрасывающие переменные в документ App. Единственная переменная, не пробрасываемая в основной документ, это _currentUser_. Ее использование происходит засчет подписки на контекст через провайдер в документе App.

```
App.js

import { CurrentUserContext } from "../contexts/CurrentUserContext.js";

export default function App() {

...

return (
<div className="app">
      <CurrentUserContext.Provider value={currentUser}>
        <div className="page">
          <Header />
          <Main... />
          <Footer />
          <EditProfilePopup ... />
          <EditAvatarPopup ... />
          <AddPlacePopup ... />
          <PopupWithForm ... />
          <ImagePopup ... />
        </div>
      </CurrentUserContext.Provider>
    </div>
)
}
```

#### 4.1.1. Загрузка информации о пользователе с сервера

Как уже говорилось ранее, информация о пользователе подгружается с сервера. Чтобы осуществить это, делался GET-запрос на URL с использованием индивидуального токена и названия когорты. Далее запрос вставлялся в основной js-файл.

#### 4.1.2. Загрузка карточек с сервера

Загрузка карточек с сервера осуществлялась через метод "PATCH" и имеет тело:

```
Api.js:

body: JSON.stringify({
        name: name,
        about: job,
      }),
```

#### 4.1.3. Редактирование профиля

Данная технология реализуется за счет запроса. В ответ на который пользователю приходит следующее:

```
{
  "name": "Marie Skłodowska Curie",
  "about": "Physicist and Chemist",
  "avatar": "https://pictures.s3.yandex.net/frontend-developer/common/ava.jpg",
  "_id": "e20537ed11237f86bbb20ccb",
  "cohort": "cohort-76",
}
```

#### 4.1.4. Добавление новой карточки

Данная технология реализуется за счет запроса, при положительном ответе которого новая карточка вставляется перед массивом из основных карточек с сервера.

```
App.js

function handleAddPlaceSubmit({ name, link }) {
    api
      .createNewCard({ name, link })
      .then((newCard) => {
        setCards([newCard, ...cards]);
        closeAllPopups();
      })
      .catch((error) => {
        //если запрос не ушел
        console.log(error);
      });
  }
```

#### 4.1.5. Отображение количества лайков карточки

Отображение количества лайков карточки реализуется за счет подсчета длинны массива лайкнувших пользователей карточку

```
{card.likes.length}
```

Переменная isLiked отвечает за проверку массива всех лайкнувших карточку на наличия в нем id текущего пользователя.

```
const isLiked = card.likes.some((i) => i._id === currentUser._id);
```

Если id текущего пользователя найден, то добавляется класс "active", и лайк ставится.

```
const cardLikeButtonClassName = `element__image-like ${
    isLiked && "element__image-like_active"
  }`;
```

#### 4.1.6. Попап удаления карточки

Создается попап удаления карточки, который всплывает при клике на значок урны. Данная технология реализуется через запрос, при положительном ответе которого всплывает попап удаления, путем добавления к нему класса _opened_.

#### 4.1.7. Удаление карточки

При нажатии в попапе удаления кнопки "Да", массив карточек, пришедший с сервера, изменяется и в нем уже отсутствует карточка, значок урны которой был нажат.

#### 4.1.8. Постановка и снятие лайка

См. п.3.1.5. Отображение количества лайков карточки

#### 4.1.9. Обновление аватара пользователя

Данная технология реализуется за счет всплытия попапа с импутом и кнопкой, при заполнении поля и нажатии кнопки вставляется на страницу и сервер новая картинка также через определенный запрос в документе Api. Состояние переменной _setCurrentUser_ меняется на _(user)_, который пришел с сервера.

#### 4.1.10. Улучшенный UX всех форм

Улучшение UX всех форм осуществляется за счет оповещения пользователе об этапах загрузки/сохранения его и(или) карточки, и(или) аватара, и(или) данных.

### 4.2 Сборка проекта. Webpack

Данная технология реализована путем использования модулей при разработке, а перед загрузкой проекта в интернет происходит сбор всех получившихся файлов в один и подключение в HTML. В процессе такой сборки код преобразуется: сжимается и работает в старых браузерах. Все это делается автоматически при сборке проэкта, благодаря реакту и быстрому старту из-за установки пакета _npx create-react-app my-app_ в программе Windows PoverShell.
Сборка проекта происходит через коммандную строку Node.js путем скачивания необходимых материалов и написания скриптов с последующим их вызовом. Также создаются файлы с типом JSON и js, в которых прописывается, "куда заглянуть" программе, куда положить собранные файлы, и что делать с файлами разных типов.

### 4.3 Регистрация пользователя

Данная технология реализауется через auth запросы. При сабмите формы _регистрации_ отправляется запрос на сервер, в случае его положительного ответа происходит следующее:

- всплывает окно "Вы успешно зарегистрировались";
- сайт переходит на страницу "Вход в систему".
  При отрицательном ответе(код статуса 400 и другие) реализовано всплывающее окно "что-то пошло не так", в консоли указана причина ошибки(для каждого запроса она имеет свое значение).

### 4.4 Авторизация пользователя

Данная технология реализауется через auth запросы. При сабмите формы _входа в систему_ отправляется запрос на сервер, в случае его положительного ответа сайт переходит на страницу с контентом.
При отрицательном ответе(код статуса 400, 401 и другие) реализовано всплывающее окно "что-то пошло не так", в консоли указана причина ошибки(для каждого запроса она имеет свое значение).

### 4.5 Вход пользователя, сохраненного в локальном хранилище

При входе в систему сохраняем данные (электронную почту и пароль) пользователя в локальном хранилице. Через перехват реакции React.useEffect при загрузки страницы проверяется наличие токена пользователя в выше описанном хранилище, при его наличии пользователь, минуя страницу входа, автоматически переходит на страницу контента.

### 4.6 Применение классов

В файле App.js, в котором осуществляются вызовы функций, создаются экземпляры компонентов посредством новых констант и импорта функций в указанный документ.

### 4.7 Валидация форм

Данная технология реализуется посредством кода из js документа. Технология представляет собой несколько этапов, содержащих по одной функции на каждое действие. Вкратце это будет звучать так:

1. При открытии любого из попапов кнопка сохраниения данных/добавления карточки неактивна.
2. При изменении данных профиля/карточки проверяется количество введенных символов(у каждого input свой интервал значений). Также проверяется является ли введенные символы в поле, где должна быть ссылка, сылкой.
3. При соответствии всех инпутов данным требованиям в каждой рассматриваемой форме кнопка сохранения/добавления становится активной.

### 4.8 Открытие и закрытие pop up по клику мышкой, нажатию на кнопку "Esc", клику на фон

Данная технология реализуется посредством кода из js документа. Ниже представлен пример открытия pop up. Технология представляет собой объявление и присвоение переменной, описание и вызов функции.

```
jS:

//константа равна открытому попапу
const isSomePopupOpen =
    isEditProfilePopupOpen ||
    isAddPlacePopupOpen ||
    isEditAvatarPopupOpen ||
    selectedCard;

//закрытие на темный фон
  const handleOverlayClose = React.useCallback((event) => {
    if (event.target.classList.contains("popup")) {
      /*закрытие всех попапов*/
      ...
    }
  }, []);

  //закрытие на esc
  const handleCloseByEsc = React.useCallback((event) => {
    if (event.key === "Escape") {
      /*закрытие всех попапов*/
      ...
    }
  }, []);

React.useEffect(() => {
    if (isSomePopupOpen) {
      document.addEventListener("keydown", handleCloseByEsc);
      document.addEventListener("click", handleOverlayClose);
      return () => {
        document.removeEventListener("keydown", handleCloseByEsc);
        document.removeEventListener("click", handleOverlayClose);
      };
    }
  }, [isSomePopupOpen]);

```

Обязательно снимае обработчики после их применения(закрытия попапа), так как нет смысла пользоваться обработчиками закрытия попапа при и так уже закрытом попапе.

### 4.9 Редактиование и сохранение данных

Данные технологии реализуется по аналогии с технологиями выше: делается запрос и при положительном его ответе именяется переменная состояния на то, что пришло с сервера/отправляется на сервер и меняется значение в разметке.

### 4.10 Добавление карточки в сплывающем pop up

См. п.3.1.4. Добавление новой карточки

### 4.11 Удаление карточки

См. п.3.1.6. Попап удаления карточки и п.3.1.7 Удаление карточки

### 4.12 Постановка лайка карточке

См. п.3.1.5. Отображение количества лайков карточки

### 4.13 Открытие картинки в большем масштабе в сплывающем pop up

Данная технология реализуется посредством кода из js документа. Ниже представлен пример открытия картинки в большем масштабе. Данная часть кода вставляется в App.js с последующей вставкой в основную разметку. При клике на картинку карточке, через пропс card в попапе в значениях ссылки на картинку и имени карточки спрашивается _card ?_ и при положительном ответе вставляется _card.name_ и _card.link_ в соответствующую разметку. _Card_ пробрасывается через пропс в App.js, где его значение меняется через переменную состояния при клике в документе Main.

### 4.14 Адаптивность сайта

Для адаптивности сайта используются медиазапросы на разные брейкпоинты. Эта технология позволяет сделать сайт доступных для устройств с различными разрешеиями.

```
CSS:

@media screen and (max-width=320px) {
  header: {
    margin-top: 6px;
  }
}
```

### 4.15 "Резиновость" сайта

Данная технология позволяет сделать сайт для комфортного просмотра между брекпоинтами с помощью изменения размеров элементов при изменении разрешения экрана.

```
CSS:
  header: {
    max-width: 320px;
    width: 100%;
  }

```

### 4.16 Флекс-элементы

Данная технология помогает изменять размеры элементов при изменении масштаба и помогает сделать сайт более "резиновым"

### 4.17 Грид-элементы

Данная технология помогает изменять размеры элементов при изменении масштаба, облегчает расположение элементов по сетке (секция elements) и помогает сделать сайт более "резиновым"

### 4.18 Подключение шрифтов;

```
@font-face {
  font-family: "Inter";
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url(./Inter/Inter-Regular.woff2) format("woff2"),
    url(./Inter/Inter-Regular.woff) format("woff");
}
```

### 4.19 "Отзывчивость" интерактивных элементов

Данная технология реализуется за счет добавления интерактивным элементам (кнопкам) css-свойства

```
opacity: 0.6;
```

или

```
opacity: 0.6;
```

### 4.20 Файловая структура проекта по правилам Nested БЭМ

```
папка "блок"
    папка "__элемент"
        папка "_ключ модификатора"
            папка "_значение модификатора"
                файл  "блок__элемент_значение модификатора"
    файл "блок__элемент.css"
файл "блок.css"
```

---


## 5. Технологии, используемые в проекте. Frontend. Backend
Данный проект реализуется на базе следующих функций:

- Инфраструктура проекта;
- База данных, контроллеры и роуты для карточек и пользователей;
- Обработка ошибок;

### 5.1 Инфраструктура проекта

Инфраструктура проекта представляется собой с папками, файлами и основным файлом app.js, а также имеет настроеные

- editorconfig(помогает поддерживать согласованные стили кодирования для нескольких разработчиков, работающих над одним проектом в различных редакторах и IDE),
- линтер(отлавливает ошибки и следит за единообразием кода),
- файлом .gitignore(служит для указания в нём файлов и папок, которые необходимо скрыть от системы контроля версий git) и т.д.

### 5.2 База данных, контроллеры и роуты для карточек и пользователей

В проекте используется mestodb. В нее записываются карточки и пользователи посредством создания моделей на основе созданных схем. Схема пользователя представляет собой объект из трех составляющих, составленных по типу 'ключ - значение'(name, about, avatar). Схема карточки состоит из 5 составляющих по тому же типу(name, link, owner, likes, createdAt).

Роуты обязательно подключаются в файле app.js, а записываются в папку router, в них используется информация о методах, ссылках запросов и контроллеры, которые записываются в отдельной одноименной папке.

Роуты и контроллеры пользователя могут следующее:

- возвращать всех пользователей,
- возвращать пользователя по id,
- возвращать текущего пользователя,
- обновлять профиль или аватар;
- аутифицировать пользователя,
- зарегистрировать(создать) пользователя.

Роуты и контроллеры карточек могут следующее:

- возвращать все карточки,
- создать карточку,
- удалить карточку по id;
- поставить/убрать лайк.

### 5.3 Обработка ошибок

В случаях, если при запросе что-то пошло не так — вернутся соответствующие коды ошибок:
400 — переданы некорректные данные в методы создания карточки, пользователя, обновления аватара пользователя или профиля;
401 - Отсутствие токена (JWT), некорректный токен (JWT), невалидный пароль;
403 - Обновление чужого профиля, чужого аватара, удаление чужой карточки;
404 — карточка или пользователь не найден;
409 - Попытка зарегистрировать вторую учетную запись на тот же email;
500 — На сервере произошла ошибка.

### 5.4 Безопасность

Безопасность данного сайта представляет собой следующие составляющие:

5.4.1. Защита Авторизацией.
Данная технология реализована засчет создания мидлвэра для авторизации, задача которого верифицировать токен и если с ним все в порядке, то добавлять пейлоуд токена в объект запроса.

```
req.user = payload;
next();
```

5.4.2. Пароли хэшируются и не возвращаются пользователю в ответе запроса.
Хэширование пароля реализовано за счет метода _bcrypt.hash_. Отсутствие пароля при возврате пользователей в ответе запроса реализовано за счет поля _select: false_ в графе pasword в схеме пользователя.

5.4.3. Безопасный способ хранения JWT в браузере
Данные в браузере сохраняются в так называемые куки. Это фрагменты данных, относящихся к определённому домену.
Такую куку нельзя прочесть из JavaScript. Токен защищен.

```
// отправим токен, браузер сохранит его в куках
res
  .cookie('jwt', token, {
        // token - наш JWT токен, который мы отправляем
    maxAge: 3600000,
    httpOnly: true
  })
  .end(); // если у ответа нет тела, можно использовать метод end
```

5.4.4. Реализована централизованная обработка ошибок
Такой способ приводит к тому, что ошибки не дублируются, а в случае отсутствия статуса и сообщения об ошибке, отправляется ошибка со статусом 500 и сообщением "На сервере произошла ошибка".

```
const getUsers = (req, res, next) => {
  // остальной код
    .catch((err) => {
      next(err);
    });
};

module.exports = (error, req, res, next) => {
  const { statusCode = 500, message } = error;
  res.status(statusCode).send({
    message: statusCode === 500 ? "На сервере произошла ошибка." : message,
  });
  next();
};

```

5.4.5. Настройка заголовков ответа
Заголовки безопасности можно проставлять автоматически — для этого есть модуль Helmet:

```
const helmet = require('helmet');
app.use(helmet());
```

5.4.6. Защита от брутфорсу и DDоSу
Чтобы защититься от множества автоматических запросов, существует специальный мидлвэр — express-rate-limit:

```
const express = require('express');
const rateLimit = require('express-rate-limit');

const app = express();

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // за 15 минут
  max: 100 // можно совершить максимум 100 запросов с одного IP
});

// подключаем rate-limiter
app.use(limiter);
```

### 5.5 Валидация

Валидация данного сайта представляет собой следующие составляющие:

5.5.1. Валидация приходящих на сервер запросов;
Тела запросов к серверу валидируются до передачи обработки в контроллеры. Если запрос принимает какую-то информацию в заголовках или параметрах, она валидируется.
API возвращает ошибку, если запрос не соответствует схеме.

5.5.2. Валидация данных на уровне схемы
Валидация данных на уровне схемы просиходит следующим образом:

```
const userSchema = new mongoose.Schema(
  {
    ...
    // информация о пользователе
    about: {
      type: String,
      minlength: [2, "Описание не должно быть короче 2-х символов"],
      maxlength: [30, "Описание не должно быть длиннее 30-и символов"],
      default: "Исследователь",
    },
    // ссылка на аватарку
    avatar: {
      type: String,
      default:
        "https://pictures.s3.yandex.net/resources/jacques-cousteau_1604399756.png",
      validate: {
        validator: (avatar) => {
          /https?:\/\/(www\.)?[a-zA-Z0-9-@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([a-zA-Z0-9()-@:%_+.~#?&//=]*)/.test(
            avatar
          );
        },
        message: "Передан некорректный электронный адрес",
      },
    },
   ...}
);
```
